PARSER_BEGIN(Lugosi)
import java.io.*;
import java.util.*;

class ProgramaLugosi{
  Main main;
  ArrayList <Func> funcs;
  ProgramaLugosi(Main p, ArrayList <Func> a) {this.main = p; this.funcs = a;}
}

class Main{
  ArrayList <VarDecl> vd;
  ArrayList <Comando> seqComandos;
  Main(ArrayList <VarDecl> vd, ArrayList <Comando> seqComandos) {this.vd = vd; this.seqComandos = seqComandos;}
}

class VarDecl{
  String id;  
  String tipo;
  VarDecl(Token id, String tipo) {this.id = id.image; this.tipo = tipo;}
}

class SeqComandos{
  ArrayList <Comando> comando; 
  SeqComandos(ArrayList <Comando> c) {this.comando = c;}
}

class Comando{}
class CAtrib extends Comando{
  String id;
  Exp e;
  CAtrib(Token id, Exp comando2) {this.id = id.image; this.e = comando2;}
}

class CExpParenteses extends Comando{
  String id;
  ArrayList <Exp> listExp;
  CExpParenteses(Token id, ArrayList <Exp> comando2) {this.id = id.image; this.listExp = comando2;}
}

class CIf extends Comando{
  Exp e;
  ArrayList <Comando> seqComandos;
  CIf(Exp e, ArrayList <Comando> seqComandos) {this.e=e; this.seqComandos = seqComandos;}
}

class CWhile extends Comando{
  Exp e;
  ArrayList <Comando> seqComandos;    
  CWhile(Exp e, ArrayList <Comando> seqComandos) {this.e=e; this.seqComandos = seqComandos;}
}

class CDo extends Comando{
  Exp e;
  ArrayList <Comando> seqComandos;
  CDo(Exp e, ArrayList <Comando> seqComandos) {this.e=e; this.seqComandos = seqComandos;}
}

class CReturn extends Comando{
  Exp e;
  CReturn(Exp e) {this.e = e;}
}

class CPrint extends Comando{
  Exp e;
  CPrint(Exp e) {this.e = e;}
}

class Exp{}

class OperacaoBinaria extends Exp{
  Exp e1;
  Exp e2;
  String operador;
}

class Fator extends Exp{}

class FId extends Fator{
  String id;
}

class FExpParenteses extends Fator {
  String id;
  ArrayList <Exp> listExp;
}

class FNumLiteral extends Fator {
  String numLiteral;
}

class FTipo extends Fator {
  String tipo;
}

class ListaExp {
  Exp e; 
}

class Func {
  String tipo;
  String id;
  ArrayList <ListaArg> listaArg;
  ArrayList <VarDecl> vd;
  ArrayList <Comando> seqComandos;

  Func(String tipo, Token id, ArrayList <ListaArg> listaArg, ArrayList <VarDecl> vd, ArrayList <Comando> seqComandos) 
  {this.tipo = tipo; this.id = id.image; this.listaArg = listaArg; this.vd = vd; this.seqComandos = seqComandos;}
}

class ListaArg{
  String tipo;
  String id;

  ListaArg(String tipo, Token id) {this.tipo = tipo; this.id = id.image;}
}

///////////////////////////////////////////////////////////////////////////////

public class Lugosi {

  public static void main(String args[]) throws ParseException,IOException {
    
    Lugosi parser = new Lugosi(new FileInputStream(args[0]));
    ProgramaLugosi lug = parser.Lugosi();
    //printer(lug)
  }
/*
  static void printer (Lugosi lug){
    if (lug istanceof )
  }
*/
}

PARSER_END(Lugosi)

//////////////////////////////////////////////////////////////////////////////////////////////q

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <VAR:"var">
| <PONTO_VIRGULA:";">
| <TIPO:("int" | "bool")>
| <ATRIBUICAO:":=">
| <APARENTESES:"(">
| <FPARENTESES:")">
| <VIRGULA:",">
| <TRUE:"true">
| <FALSE:"false">
| <IF: "if">
| <WHILE:"while">
| <DO:"do">
| <RETURN:"return">
| <PRINT:"print">
| <FUNCTION:"function">
| <TOKEN_ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])* ("_")*>
| <TOKEN_NUMLITERAL:(["0"-"9"])+ ("."(["0"-"9"])+ )? ("E" ("+" | "-")? (["0"-"9"])+)?>
}

TOKEN :
{
 <OP: ("+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "==")>
|< ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])*>

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

ProgramaLugosi Lugosi () :
{Main p; ArrayList<Func> a;}
{ 
  p = Main() (a=Func())? <EOF> 
  {return new ProgramaLugosi(p,a);}
   
}

ArrayList<Func> Func():
{ArrayList<Func> func; ArrayList f; String tipo;  Token id; ArrayList <ListaArg> listaArg; ArrayList <VarDecl> vd; ArrayList <Comando> seqComandos;}
{
  (<FUNCTION> tipo = Tipo() id = <TOKEN_ID> <APARENTESES> (listaArg = ListaArg()) <FPARENTESES>
     <ACHAVES> (vd = VarDecl()) (seqComandos = SeqComandos()) <FCHAVES>  {func.add(new Func(tipo, id, listaArg, vd, seqComandos));  })+
  
  {return func;}
}

ArrayList<ListaArg> ListaArg():
{ArrayList<ListaArg> a; String tipo; Token id;}
{
  (tipo = Tipo() id = <TOKEN_ID> <PONTO_VIRGULA> ListaArg() {a.add(new ListaArg(tipo, id));} )?

  {return a;}
}

Main Main ():
{ArrayList <VarDecl> vd; ArrayList <Comando> seqComandos;}
{
 <MAIN> <ACHAVES> (vd = VarDecl()) (seqComandos = SeqComandos()) <FCHAVES>
  {return new Main(vd, seqComandos);} 
}

ArrayList<VarDecl> VarDecl():
{ArrayList<VarDecl> a;  Token id; String tipo;}
{
  (<VAR> tipo = Tipo() id =  <TOKEN_ID> <PONTO_VIRGULA>  {a.add(new VarDecl(id, tipo));}  )*
  {return a;}
}

String Tipo():
{Token t;}
{
  t = <TIPO>
  {return t.image;}
}

ArrayList<Comando> SeqComandos():
{ArrayList<Comando> c; Comando comando;}
{
  (comando = Comando() {c.add(comando);})*
  {return c;}
}

Comando Comando():
{Token id; Exp e; ArrayList<Comando> seqComandos; ArrayList<Exp> listExp; Object comando2;}
{
  ((id = <TOKEN_ID>) (comando2 = Comando2()))
  	{if (comando2 instanceof Exp)  return new CAtrib(id, ((Exp) comando2));
      else return new CExpParenteses(id, ((ArrayList<Exp>) comando2)); }

  |(<IF> <APARENTESES> (e=Exp()) <FPARENTESES> <ACHAVES> (seqComandos=SeqComandos()) <FCHAVES> <PONTO_VIRGULA>)
      {return new CIf(e, seqComandos);}
    
  |(<WHILE> <APARENTESES> (e=Exp()) <FPARENTESES> <DO> <ACHAVES> (seqComandos=SeqComandos()) <FCHAVES> <PONTO_VIRGULA>)
  	{return new CWhile(e, seqComandos);}
  
  |(<DO> <ACHAVES> (seqComandos=SeqComandos()) <FCHAVES> <WHILE> <APARENTESES> (e=Exp()) <FPARENTESES> <PONTO_VIRGULA>)
  	{return new CDo(e, seqComandos);}
  
  |(<RETURN> (e=Exp()) <PONTO_VIRGULA>)
  	{return new CReturn(e);}
  
  |(<PRINT> <APARENTESES> (e=Exp()) <FPARENTESES> <PONTO_VIRGULA>)
  	{return new CPrint(e);}

}

//Comando 2 criado para eliminar a recursão da gramática
Object Comando2():
{Object e;}
{
  (<ATRIBUICAO> (e=Exp()) <PONTO_VIRGULA>)
  	{return e;} 
  
  |(<APARENTESES> (e=ListaExp()) <FPARENTESES> <PONTO_VIRGULA>)
  	{return e;}
}

Exp Exp():
{Exp e1; Exp e2; Token operador; Fator f;}
{
  (<APARENTESES> e1= Exp() operador = <OP> e2 = Exp() <FPARENTESES>)
    {return new OperacaoBinaria(e1, e2, operador.image);}
  | f = Fator()
    {return f;}
}

ArrayList<Exp> ListaExp():
{Exp e; ArrayList<Exp> l; ArrayList<Exp> l2;}
{
  e = Exp() l2=ListaExp2()
  {l.add(e); return l.addAll(l2);}
}

//Criada para eliminar a recursao em ListExp
ArrayList<Exp> ListaExp2():
{Exp e; ArrayList<Exp> l;}
{
  (<VIRGULA> e = Exp() ListaExp2() {l.add(e);})?
  {return l;}
}

Fator Fator():
{Token id; Token numLiteral; Token tipo;}
{
  (id = <TOKEN_ID> Fator2()) 
    {return}

  | numLiteral = <TOKEN_NUMLITERAL> 
    {return new FNumLiteral(numLiteral.image);}
  
  | tipo = <TRUE>
    {return new FTipo(tipo.image);} 
  
  | tipo = <FALSE>
    {return new FTipo(tipo.image);}
}

ArrayList<Fator2> Fator2():
{ArrayList<Exp> l; ArrayList<Fator2> f2;}
{
  (<APARENTESES> l = ListaExp() <FPARENTESES>{f2.add(l);}) ?
  {return f2;}
}
