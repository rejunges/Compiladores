PARSER_BEGIN(Lugosi)
import java.io.*;

class ProgramaLugosi{
  Main main;
  ArrayList <Func> funcs;
  ProgramaLugosi(p,a) {this.p = main; this.a = funcs;}
}

class Main{
  ArrayList <VarDecl> vd;
  ArrayList <SeqComandos> seqComandos;
  Main(vd, seqComandos) {this.vd = vd; this.seqComandos = seqComandos;}
}

class VarDecl{
  String id;  
  String tipo;
  VarDecl(id, tipo) {this.id = id.image; this.tipo = tipo;}
}

class SeqComandos{
  ArrayList <Comando> comando; 
  SeqComandos(comando) {this.c = comando;}
}

class Comando{}
class CAtrib extends Comando{
  String id;
  Exp e;
}

class CExpParenteses extends Comando{
  String id;
  ArrayList <ListaExp> listExp;
}

class CIf extends Comando{
  Exp e;
  ArrayList <SeqComandos> seqComandos;
  CIf(e, seqComandos) {this.e=e; this.seqComandos = seqComandos;}
}

class CWhile extends Comando{
  Exp e;
  ArrayList <SeqComandos> seqComandos;    
  CWhile(e, seqComandos) {this.e=e; this.seqComandos = seqComandos;}
}

class CDo extends Comando{
  Exp e;
  ArrayList <SeqComandos> seqComandos;
  CDo(e, seqComandos) {this.e=e; this.seqComandos = seqComandos;}
}

class CReturn extends Comando{
  Exp e;
  CReturn(e) {this.e = e;}
}

class CPrint extends Comando{
  Exp e;
  CPrint(e) {this.e = e;}
}

class Exp{}

class OperacaoBinaria extends Exp{
  Exp e1;
  Exp e2;
  String operador;
}

class Fator extends Exp{}

class FId extends Fator{
  String id;
}

class FExpParenteses extends Fator {
  String id;
  ArrayList <ListaExp> listExp;
}

class FNumLiteral extends Fator {
  String numLiteral;
}

class FTipo extends Fator {
  String tipo;
}

class ListaExp {
  Exp e; 
}

class Func {
  String tipo;
  String id;
  ArrayList <ListaArg> listaArg;
  ArrayList <VarDecl> vd;
  ArrayList <SeqComandos> seqComandos;

  Func(tipo,id,listaArg,vd,seqComandos) {this.tipo = tipo; this.id = id.image; this.listaArg; this.vd = vd; this.seqComandos = seqComandos;}
}

class ListaArg{
  String tipo;
  String id;

  ListaArg(tipo, id) {this.tipo = tipo; this.id = id.image;}
}

///////////////////////////////////////////////////////////////////////////////

public class Lugosi {

  public static void main(String args[]) throws ParseException,IOException {
    
    Lugosi parser = new Lugosi(new FileInputStream(args[0]));
    ProgramaLugosi lug = parser.Lugosi();
    //printer(lug)
  }
/*
  static void printer (Lugosi lug){
    if (lug istanceof )
  }
*/
}

PARSER_END(Lugosi)

//////////////////////////////////////////////////////////////////////////////////////////////q

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <VAR:"var">
| <PONTO_VIRGULA:";">
| <TIPO:("int" | "bool")>
| <ATRIBUICAO:":=">
| <APARENTESES:"(">
| <FPARENTESES:")">
| <VIRGULA:",">
| <TRUE:"true">
| <FALSE:"false">
| <IF: "if">
| <WHILE:"while">
| <DO:"do">
| <RETURN:"return">
| <PRINT:"print">
| <FUNCTION:"function">
| <TOKEN_ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])* ("_")*>
| <TOKEN_NUMLITERAL:(["0"-"9"])+ ("."(["0"-"9"])+ )? ("E" ("+" | "-")? (["0"-"9"])+)?>
}

TOKEN :
{
 <OP: ("+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "==")>
|< ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])*>

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

ProgramaLugosi Lugosi () :
{ProgramaLugosi p; ArrayList<Func> a;}
{ 
  p = Main() (a=Func())? <EOF> 
  {return new ProgramaLugosi(p,a);}
   
}

ArrayList Func():
{ArrayList func = new ArrayList(); String tipo;  Token id; ArrayList <ListaArg> listaArg; ArrayList <VarDecl> vd; ArrayList <SeqComandos> seqComandos;}
{
  (
    {func.add(
      <FUNCTION> (tipo = Tipo()) (id = <TOKEN_ID>) <APARENTESES> (listaArg = (ListaArg()))? <FPARENTESES>
     <ACHAVES> (vd = VarDecl()) (seqComandos = SeqComandos()) <FCHAVES>
     )}
     )+
  {return func;}
}

ArrayList ListaArg():
{ArrayList a = new ArrayList(); String tipo; Token id;}
{
  (
    {a.add(
      (tipo = Tipo()) (id = <TOKEN_ID>) (<PONTO_VIRGULA> ListaArg())
      )}
      )?
  {return a;}
}

Main Main ():
{ArrayList <VarDecl> vd; ArrayList <SeqComandos> seqComandos;}
{
 <MAIN> <ACHAVES> (vd = VarDecl()) (seqComandos = SeqComandos()) <FCHAVES>
  {return new Main(vd, seqComandos);} 
}

ArrayList VarDecl():
{ArrayList a = new ArrayList;  Token id; String tipo;}
{
  ({
    a.add(<VAR> (tipo = Tipo()) (id =  <TOKEN_ID>) <PONTO_VIRGULA>)
    })*
  {return a;}
}

String Tipo():
{String t;}
{
  t = <TIPO>
  {return t;}
}

ArrayList SeqComandos():
{ArrayList<Comando> c = new ArrayList();}
{
  ({
  	c.add(Comando())
  })*
  {return c;}
}

void Comando():
{Token id; Exp e; ArrayList <SeqComandos> seqComandos; ArrayList<ListExp> listExp;}
{
  ((id = <TOKEN_ID>) (listaExp or e= Comando2()))
  	//{RETORNA OU LISTAEXP OU EXP E ISSO IMPACTA EM QUAL FUNCAO CHAMAR, PRECISAMOS DE UM HELPPPPPP}
  //ESSES RETURNS COM PIPE PRECISAM TER MAIS UM PARENTESES NA VOLTA?????????????????????
  |(<IF> <APARENTESES> (e=Exp()) <FPARENTESES> <ACHAVES> (seqComandos=SeqComandos()) <FCHAVES> <PONTO_VIRGULA>)
  	{return new CIf(e, seqComandos)}
  
  |(<WHILE> <APARENTESES> (e=Exp()) <FPARENTESES> <DO> <ACHAVES> (seqComandos=SeqComandos()) <FCHAVES> <PONTO_VIRGULA>)
  	{return new CWhile(e, seqComandos)}
  
  |(<DO> <ACHAVES> (seqComandos=SeqComandos()) <FCHAVES> <WHILE> <APARENTESES> (e=Exp()) <FPARENTESES> <PONTO_VIRGULA>)
  	{return new CDo(e, seqComandos)}
  
  |(<RETURN> (e=Exp()) <PONTO_VIRGULA>)
  	{return new CReturn(e)}
  
  |(<PRINT> <APARENTESES> (e=Exp()) <FPARENTESES> <PONTO_VIRGULA>)
  	{return new CPrint(e)}

}

//Comando 2 criado para eliminar a recursão da gramática
void Comando2():
{Exp e; ArrayList<ListaExp> listaExp;}
{
  (<ATRIBUICAO> (e=Exp()) <PONTO_VIRGULA>)
  	{return e;} 
  
  |(<APARENTESES> (listaExp=ListaExp()) <FPARENTESES> <PONTO_VIRGULA>)
  	{return listaExp;}
}

void Exp():
{}
{
  (<APARENTESES> Exp() <OP> Exp() <FPARENTESES>)
  | Fator()
}

void ListaExp():
{}
{
  Exp() ListaExp2()
}

//Criada para eliminar a recursao em ListExp
void ListaExp2():
{}
{
  (<VIRGULA> Exp() ListaExp2())?
}

void Fator():
{}
{
  (<TOKEN_ID> Fator2()) 
  | <TOKEN_NUMLITERAL> 
  | <TRUE> 
  | <FALSE>
}

void Fator2():
{}
{
  (<APARENTESES> (ListaExp())? <FPARENTESES>)?
}
